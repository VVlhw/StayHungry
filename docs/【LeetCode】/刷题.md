# LeetCode刷题篇

## 数学

**序列和**
给出一个正整数N和长度L，找出一段长度大于等于L的连续非负整数，他们的和恰好为N。答案可能有多个，我我们需要找出长度最小的那个。
例如 N = 18 L = 2：
5 + 6 + 7 = 18
3 + 4 + 5 + 6 = 18
都是满足要求的，但是我们输出更短的 5 6 7
`开始以为前缀和，发现没指明起点。【是等差数列】长度知道【L，100】，总和知道Sn==N，这样就能求出a1了。如何判断一个double是不是没小数，ceil(Double) == Double 判断就好了。double++ 和 int++好像不同，换了成int就过了，不知道是不是类型要求`
**等差数列公式**
**an=a1+(n-1)\*d
Sn=a1\*n+[n\*(n-1)\*d]/2 或 Sn=[n\*(a1+an)]/2**
**等比数列公式**
**an = a1\*q^(n-1)
Sn = a1(1-q^n) / (1 – q) 【q !=1】**



## 排序

[面试题45. 把数组排成最小的数](https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)
给你一堆数字字符串，要求返回**字面最小**拼接的情况。
`思路：`首先无疑高位数字越小越好，但这是按字面量比较的，就是说40字面量>3，显然340拼接更优，所以我们是不能根据字面量排序的。如何排？先说两个例子：221、22——221 22更好；226、22——22 226更好。一开始想歪了，又考虑什么最后一个数比前一个大什么。。。。`(s1, s2) -> (s1 + s2).compareTo(s2 + s1)`就好了，比一下不就知道了吗，找什么规律。
`再优化：`分10组【0，9】放那些0开头、1开头的。各自排序。因为0开头一定比1开头优，这样能减少全部一起排序的消耗。



[面试题40. 最小的k个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)
TOPK问题
`排序nlogn、堆nlogk、快排思想On`（利用那个基准的位置，然后基准左边都是小于等于基准的）
扩展：`BFPRT算法`（On，和快排思想一样能找到第K大）

## 位运算

**注意优先级**，加括号什么的，特别二分那里、（num & tmp）== 0

判断一个数奇偶，就是看2^0是否1，所以 `num & 1` 快速判断
`树状数组` 它是`n & -n`
结论：当一个数与其取负后的值相与， 如果这个数是偶数， 则结果是能整除这个偶数的最大的2的幂(即： m = n & -n , 则 n % m = 0, 且 m = 2 ^ k)， 如果这个数是奇数， 则结果必为1
用途：获取某个二进制数的LowBit
[详细过程分析参考](https://blog.csdn.net/oyoung_2012/article/details/79932394)

[面试题15. 二进制中1的个数](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/)

![img](https://vvlhw-1301628378.cos.ap-guangzhou.myqcloud.com/%E5%88%B7%E9%A2%98/%E5%88%B7%E9%A2%98%20%281%29.png)

[面试题56 – I. 数组中数字出现的次数](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/)
很秀，“只有一个数字出现一次”的升级版——有两个数字出现一次。
对于这种**成对出现的**，应该要能马上Q到`异或`
这题难在于这两个数字都异或到一起，怎么分开。根据异或的原理，其他成对出现的没影响，然后二进制某位1代表这两个数字这里的对应位是不同的，按照这个特征，制定规则分组，保证这两个出现一次的数字不在同一组。

[面试题39. 数组中出现次数超过一半的数字](https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/)
思路：
①排序O(nlogn)， 空间O(1) 。输出nums[nums.length / 2]
②扫一遍O(n)，空间O(n)。统计每个数字的次数，需要一个数组。输出次数大于一半的那个。
③`摩尔投票法` 时间和空间复杂度分别为 O(N)和 O(1)*。*`核心观念：正负抵消`
特别适合这种，只有运行完才能确定，运行时**动态变化**我们所**假设的**那个众数。
设众数为+1，其它-1。那一定总和是>0。只要发生count==0，说明此刻假设的众数是**暂时**不对的，以为目前为止有跟假设的一样次数的数，那就相当于抵消，相当于没有，所以就假设下一轮的nums[i]

## 单调栈、单调双端队列、twoPoint、动态编程/DP

[42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)
实际就是对于每个位置，左右找最高的柱子，两个柱子高度取min，就是**当前位置能接到的雨水**
`学会拆成小问题。题目是整个图能接多少雨水，应该看成，每个位置能接雨水之和`
解法：
① 每个位置，左for，右for，找左右最高。
② 其实不必嵌套里面，拿出来用数组记录好，类似前缀和这样，`能从前一个得到信息，再与当前位置高度比较`就好了
③ `单调栈`。栈的特点是FILO。意味着我们能取**最近的**。我不必考虑当前位置最终接了多少雨水，只考虑**界定**我当前这个位置能接多少，也就是算的是**部分的水**，而后续利用栈存的是**下标**，会补上剩余的雨水的。
`how界定：单调栈，这里是一个单调递减的。栈顶就是当前能界定的，即我往右遍历遇到一个比栈顶位置高的，那右边界定的找到了。左边界定的呢？想想栈是取最近的，而且我们是单调递减的存，那栈顶的下一个是不是就是左边界定那个。`
④ `双指针`。结合②发现的规律。最终优化成On时间复杂度，O1空间复杂度

[面试题09. 用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)
[面试题30. 包含min函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/)
考察栈的FILO， 09题没必要两次出栈压到另一个栈，判断空时才进行，优化了
30题用一个**辅助栈**维持一个从栈顶到栈底非严格递增，然后pop的时候，**比较两个栈顶是否相等来保持一致性**
总结：其实这些`最值问题`，基本就是一个数据结构（栈/队列）保持单调，一般是非严格单调。

**字节跳动面试题**
给一堆房子高度，问每个房子左右能看见多少（自己看不见自己，看见：小于等于自己高度）
暴力肯定超时，
本质不就是：**找左右第一个比自己高的吗**，不就是适合`单调栈`吗。  
分解不就是：  
①找右边第一个比自己高 rightTall[i]  
②找左边第一个比自己高 leftTall[i]  
`ans[i] = rightTall[i] - leftTall[i] - 2` 减多一个 1是因为：自己看不见自己
解法：  从左往右扫，非严格单调递减的栈，遇到第一个 比栈顶高，他右边比他自己高的就已经确定了。反过来再来一遍
还是那句话，学会找问题本质，找出最小子问题，涉及方向就分开来做，而不是想怎么合一起算出来，单调栈早就想到了，就是合一起不会coding，😔
**这个思路是没问题的，已经对拍过10分钟，与暴力算法结果一致。**


[面试题59 – I. 滑动窗口的最大值](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)
又是这种最值问题。我觉得最值问题多向`前缀最值`考虑考虑
对于数组，保存值，`最好存的是下标`，好处有两点：**通过下标访问值；通过下标算出距离**
难点在于：窗口的移动，会导致原本最大那个值不在窗口范围内，那窗口最值就需要重新考察。所以用一个变量记最值也不可行。
解法：
① `双端单调队列`。队列内单调递减，**队头自然就是最大值**，通过下标，可以poll队头，维护当前窗口，而且队头还是满足最值。
② `DP`。分块很秀的，把数组按窗口大小**分成一个个块**，考虑窗口的情况。`max(toRight[windowRight], toLeft[windowLeft])`

[面试题59 – II. 队列的最大值](https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/)
`双端单调队列`
本算法基于问题的一个重要性质：当一个元素进入队列的时候，它前面所有比它小的元素就不会再对答案产生影响 。



## 搜索DFS、BFS

[面试题13. 机器人的运动范围](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)
`数据量很小，应该画图看看规律`。发现优化点：**只要向下向右**就能遍历全部
`DFS、BFS、递推`

## 堆

[面试题41. 数据流中的中位数](https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/)
定义两种操作，插入一个数、计算中位数。
最暴力就是每插入一个数字就sort一遍，取中位数。显然时间浪费在了排序上
对顶堆，就是假设有一段排好序的序列，左边一半放在最大堆，右边一半放在最小堆。这样取两个堆顶就知道中位数
**难点！！我不排序怎么把左边一半放最大堆，右边一半放最小堆**
由于我动态插入，**那不妨先放到最大堆，然后把最大堆堆顶弹出放到最小堆。再根据两个堆的容量判断是否需要把最小堆堆顶弹出放到最大堆。**我`不太会解释这样为什么能做到不排序却把左右边部分放好`。反正最大堆容量要么等于最小堆容量，要么多1。反正我感觉在平衡的这个过程中，放在堆的值不是就固定在一开始放的那个堆，大的放右边，小的放左边。太秀了。。。。

## 树

[面试题26. 树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)
给你两个树的根结点A、B，判断B是否A的子树。
没办法只能遍历的了。`前序遍历`A树，每次都拿这个A遍历到的cur结点去尝试看是否和B树一样。
关键在于**递归的设计**，**结束条件**的判断

[面试题37. 序列化二叉树](https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/)
发现了一个规律：对于k叉树，然后是层序遍历的话，从0开始编号，存在i编号，`k *（i - 前面null个数）+ 【0，k）`，这 i 结点的k个孩子们

[面试题34. 二叉树中和为某一值的路径](https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)
DFS遍历树。

!> 值得一提的是：用Java犯了个小错，由于ans.add(temp)，temp是一个LinkedList，`是对象`，而这个temp后面又回溯，会更新内容，所以应该ans.add(new LinkedList(temp))。

!> 还有一点是，对于后面有回溯操作，即使前面已经确定找到答案，也要考虑return是否有影响

[面试题28. 对称的二叉树](https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/)DFS，反着递归就好，注意大家都是叶子才行，不能一个是一个不是

[面试题55 - II. 平衡二叉树](https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/)主要还是考察写递归，注意是`所有`子树都是平衡树才是平衡树

尝试一种更优雅的递归，不返回高度，但是Java又没引用，怎么通知上层子树高度呢？我想到了传Integer对象，下层到叶子就更新Integer，因为大家指的都是一个地方，更新自然能知道。但是Integer是不可变的。只有new，但new了就不是指一个地方了。`因此我包装了一个int，这个能改变，上层能知道变化`。

```java
class myInteger {
    int value;
}
```

!> [Java只有值传递](https://juejin.im/post/5e18879e6fb9a02fc63602e2)  ①基本类型拷贝到形参交换是没有用的。②多个对象指向同一个东西，就能改变状态，其他对象能感知。③`如果一个对象引用只有一处，不要让这个引用再引用新的对象。（导致原来的没法找到，内存泄漏）`。④对象相当于指针，能做到类似引用的效果，但对于不可变类，如Integer的value不能改，只能读，重新new一个?那就导致上面层的指向不同， 更加感知不到你的变化，`解决方法：包装一下相应基本类型`

[面试题32 - I. 从上到下打印二叉树](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/)BFS

[面试题32 - II. 从上到下打印二叉树 II](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)

[面试题32 - III. 从上到下打印二叉树 III](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)主要给的TreeNode没有结点是几层数这个信息，因此包装一下BFS就好了，不过题解说可以不用包装TreeNode，能设计好，如下（我没想到。。）

```java
while(!queue.isEmpty()) {
    // for(A;B;C) A只执行一次，其他每次都重新调用，
    // 所以反过来循环，而不是i=0 i<Q.size() ++i
    // 这个i初始化一次，第一次是root这 1一个
    // 跑完这个for i又初始化为 第二层存在的个数
    for(int i = queue.size(); i > 0; i--) {
       // 放入queue 
    }
}
```

[面试题07. 重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)经典题。前序第一个一定是根，题目结点value唯一，因此能确定这个根在中序哪里，自然就确定了左右子树，对于左右子树，还是同样的解决方法。递归`solve(前序根的下标p_root，中序左边界in_left，中序有边界in_right)`。更新时，对于`左子树solve(p_root+1, in_left, 当前根中序位置-1)、右子树solve(p_root+当前根中序位置-1-in_left+1+1， 当前根中序位置+1， in_right)`加完左子树节点数不就到右子树了嘛

递推的方式也很有意思，关键在于是谁的右子树呢（相等的最后的一个）

扩展：如果value不唯一，能做吗？显然不能，中序、先序都是1，怎么看。。。

!> 判断一个arr[] 无效：if (arr== null || arr.length == 0) 。先判断空，再者不空可能长度也0

[面试题68 - I. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/)。利用搜索树的性质，能快速知道走那边，一旦在两侧就是答案了。

[面试题68 - II. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

!> 学习了，不像上题有那个特性，这个得遍历完才知道，关键如何返回是个难点——匹配了就返回点，并且**利用null就返回另一边，两边都有就是答案，返回当前结点，而返回回去必定另一侧是null，就会选择性的一直把这个点返回上去最上层，秀！**。

## 链表

[21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)
简单难度。只是`递归`（不需要额外的头结点）的方法我又没想到，`迭代`（需要一个头结点辅助）做的

## 数组、差分数组

[D. Constant Palindrome Sum](http://codeforces.com/contest/1343/problem/D)
CF就是练思维。
*给你n长度的arr，k（数组每位是【1，k】。代表你能把数组某位换成【1，k】）*  
*问你最少换多少次，使得 a[i] + a[n-i+1] 都是 = 一个 x*
x是求不出来了，怎么办，枚举它。与 *a[i] + a[n-i+1]* 有关。
很难想到利用最值来判断在某个区间会至少几次操作，`涉及区间加减——差分数组/线段树`

## 规律题

[B. K-th Beautiful String](http://codeforces.com/contest/1328/problem/B)
把**关注点放在只有少数**两个的b上，而不是任意多的a上。
技巧：**预先判断** while (cnt + tmp < k)、**拿纸写写映射关系找规律**