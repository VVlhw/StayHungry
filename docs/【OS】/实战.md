# 实战

## 1、Segmentation Fault原因总结

我由于if、else if漏掉一个条件，然后运行就报了这个段错误

[更多参考博客](https://blog.csdn.net/qq_36589706/article/details/81505221)



## 2、makefile教程——处理多文件链接

新建makefile文件，名字不能改

要有tab键，注意如果设置了tab键转空格，一定要改回tab键

```js
/*
目标: 依赖
Tab键+命令
*/
test: test.c
	gcc test.c -o test	//最前面一定要是Tab键
留一行    
```

运行直接打`make命令`

那多文件呢，gcc test.c test2.c test3.c -o main

相比makefile有什么不好，如果某个文件改动了，如test2.c，上面这样的每次所有文件都要重新编译生成目标文件，再链接。而makefile的话只重新编译改的那个，大大节省时间



```js
// 推荐用变量，方便后续改编译器选项、条件  使用方式：$(变量)
CC = gcc
CFLAGS = -g -lm


// 【makefile 只根据第一条】，如何弄多个可执行文件
//all: main_max main_min

// 【从后往前写，执行方向是从下到上，就是往下找需要的】
main: main.c tool.o
	$(CC) main.c tool.o -o main

tool.o: tool.c
	$(CC) -c tool.c	//-c 代表目标文件名字和你.c的一样

// 【推荐】加一段删除脚本，因为后续发布 不需要这些
clean:
	rm *.o main
    
```

[B站教程](https://www.bilibili.com/video/BV1Mx411m7fm?from=search&seid=11596285929611935544)



## 3、动态链接库DLL

即 Dynamic-Link Library。

为什么要用这个东西

> 想想程序之间其实有相当多的**重复代码**。在DOS时代，做法是把这些重复的代码写成一个个的函数，放到不同的库文件中去。当要使用这些函数时，只要把您的目标文件（. obj)文件和先前存放在库文件中的函数进行链接，链接时链接器会从库文件中抽取相关的信息并把它们插入到可执行文件中去。这个过程叫做`静态链接`。C运行时库就是一个好例子。
>
> <mark>缺点</mark>：在每一个调用库函数的程序中都必须嵌入同一函数的**拷贝，这显然很浪费磁盘。**
>
> 
>
> 在DOS时代毕竟每一时刻仅有一个程序在运行，所以浪费的还只是磁盘而已，在多任务的WINDOWS时代就不仅浪费磁盘，还要浪费宝贵的内存了。 
> 在WINDOWS中，由于有多个程序同时运行，如果您的程序非常大的话，那将消耗相当多的内存。WINDOWS的解决办法是：使用`动态链接库`。
>
> 
>
> 动态链接库从表面上看也是一大堆的通用函数，不过即使有多个程序调用了它，在内存中也仅仅只有动态链接库的**唯一一份拷贝**。WINDOWS是通过**分页机制**来作到这一点的
>
> <mark>优点</mark>：库的**代码只有一份**。每一个应用程序有自己单独的数据段，不会乱掉
>
> 不象旧时的静态链接库，它并不会把这些函数的可执行代码放入到应用程序中去，而是**当程序已经在内存中运行时，如果需要调用该函数时才调入内存也即链接**。 这也就是为什么把它叫做“动态”的原因所在
>
> 
>
> <mark>总结一下：几个使用DLL的点</mark>
>
> **多个exe共用一个DLL，内存只加载进去一份，节省memory**
>
> **你不想你的源码给人家，但又想人家用你的函数，那这时候你可以给你的so文件，让人家用**
>
> **用DLL可以让项目模块化，有时候只更新重新编译过的DLL就可以了，其他的东西不用动**

使用方法：

① 生成动态库libtest.so

```js
// -fpic：生成位置无关代码，用相对地址
// -shared：链接时告诉有动态链接库
// 参考下面“-I”（大写i），“-L”（大写l），“-l”（小写l）
g++ -fpic -shared -o libtest.so a1.cpp a2.cpp
```

②  使用动态链接库，在代码上用相应的函数打开它，调用它、关闭它

```js
#include<dlfcn.h>
// 返回NULL出错，mode一般是【RTLD_LAZY】：动态的加入动态链接库中的函数
void *dlopen(const char *file, int mode);
// 返回NULL出错，FuncName：动态链接库中的函数名
void *dlsym(void *handle, const char *FuncName);
// 当dlopen、dlsym等函数出错时，dlerror返回字符串说明这些函数出错的原因
char *dlerror();
// 卸载动态链接库
int dlclose(void *handle);
```

✨注：**C语言没有重载**，所以对于dlsym函数的FuncName函数名完全就是那个包含在动态库文件的函数名，是相等的。而**C++有重载**，因此需要`nm xxx.so`文件去看看具体编译成什么名字，再赋值给FuncName。或者在相应的函数前加上`extern "C" `，这样C++就会按C的风格，不改名

③ 动态库使用者的编译，也就是编译那个写了大量操作动态库函数代码的cpp文件，加`-ldl`

```js
g++ main.cpp -o main –ldl
```





我们用gcc编译程序时，可能会用到**“-I”（大写i），“-L”（大写l），“-l”（小写l）**等参数

`-I`（大写i）就代表include那些，即头文件目录

`-L`（大写L）就代表link链接的库目录

`-l`（小写l）就代表so文件名，动态库如果命名遵循 `libxxx.so的话，就写成-lxxx`

> 例：
>
> `gcc -o hello hello.c -I /home/hello/include -L /home/hello/lib -lworld`
>
> 上面这句表示在编译hello.c时：
>
> `-I` /home/hello/include表示将/home/hello/include目录作为第一个寻找**头文件的目录**，寻找的顺序是：/home/hello/include-->/usr/include-->/usr/local/include 
>
>  
>
> `-L` /home/hello/lib表示将/home/hello/lib目录作为第一个寻找**库文件的目录**，寻找的顺序是：/home/hello/lib-->/lib-->/usr/lib-->/usr/local/lib
>
>  
>
> `-lworld`表示在上面的lib的路径中寻找**libworld.so动态库文件**（如果gcc编译选项中加入了“-static”表示寻找libworld.a静态库文件），程序链接的库名是world



## 4、读文件

```c++
#include <dirent.h>

DIR *dir;
struct dirent *dt;

//出错返回NULL
if ((dir = opendir(pluginPath)) == NULL) {
    printf("opendir   %s   error\n", pluginPath);
    return false;
}

while ((dt = readdir(dir)) != NULL) {
    //获取文件名字，转成string，方便拼接
    string fileName = dt->d_name;
    //过滤掉 .  和 ..
    if (fileName[0] == '.' ||
        fileName.substr(fileName.length() - 3, 3) != ".so") {
        continue;
    }
    string wholePath = pluginPath;
    wholePath += "/" + fileName;
    v_plugin.push_back(wholePath);
}
closedir(dir);
```

